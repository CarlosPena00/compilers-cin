* steps:

 - Update the variables (output file...) in the scripts xgcc and cc1

 - In the objdir/gcc folder:
   - replace xgcc with the provided script (renaming the binary to xgcc-orig)
   - replace cc1 with the provided script (renaming the binary to cc1-orig)

 - Extract the pointers to the members of global_options (global
  variable of type gcc_options): 

   - run gdb on xgcc-orig/cc1-orig
   - (if needed) Update 'gdb-dump-optstruct' with the desired
     variables to be monitored. One easy way to list all possible
	 config variables is to run 'ptype global_options' on the gdb prompt.
	 
   - execute 'source gdb-dump-optstruct' in the gdb prompt
   - update the input file ({xgcc|cc1}-addresses.in) with the pointers in
    dump-struct.txt
	 - emacs' rectangle cut/yank (C-x r k and C-x r y) can help with that


 - Run a test (ex: 'make check-gcc RUNTESTFLAGS="dg.exp=Werror-1.c"')
   - Remember to execute the command from the objdir folder.
   - check output files (xgcc-trace.out, cc1-trace.out)

 - Set up splat:
   - Unpack splat in the parent directory of 'objdir'
   - Update the variables $LOGFILE,$TMPDIR,$OUTFILE according to your machine
   - In line 39 ("grep -R '[splat]...'"), change the input file for grep
     to the file generated by the instrumented cc1. Ex:

	 grep -E "^\[splat\]" "/home/ubuntu/workspace/gcc/cc1-trace.out" > $FEATURE_ACCESSES
    

* Notes

 - The code was tested on gcc 4.8.2, in a ubuntu x64 machine.



* TODO:

- Update memorytrace.cpp with the correct size of the types (ex: 1-sized bools...)
- Make it faster: instrumenting all memory access is too slow!
  - Currently, every memory access = one lookup in a map
- Make the scripts portable (or at least reuse the values of some variables)
